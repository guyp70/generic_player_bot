<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>Beta.Remote_Environment API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Beta.Remote_Environment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from Server.Shared_Code import *
import socket
import queue
import select
from Server.Environments import Environment


class RemoteEnvironmentsManager(Threadable):
    EnvironmentIDFormat = &#34;env%d&#34;
    Select_Timeout = 0.01
    Server_Check_Timeout = 5
    QueueGetTimeout = 5

    def __init__(self, server_ip, server_port, icon_display_size=(250, 250)):
        &#34;&#34;&#34;
        The instances of these class allow the creation of remote environments run on the server and the interaction
        with said environments via the instances of the RemoteEnvironmentTerminal class it creates and passes to the
        client.
        The user (the programmer using the class, not the user of the project as a whole) only uses this class to create
        environments and seemingly uses the instances of the  RemoteEnvironmentTerminal class returned in the
        self.get_new_remote_environment_terminal() to interact with the environment run on the server.
        Unbeknown to user though, it is the instance of this class that actually handles all communications with the
        server. The RemoteEnvironmentTerminal instances communicating through the RemoteEnvironmentsManager instance
        that created them.  

        :param server_ip: Server ip (string).  
        :param server_port: Server port (int).  
        :param icon_display_size: The size of the icon display widget. (tuple of 2 ints (width, height))
        &#34;&#34;&#34;
        super(RemoteEnvironmentsManager, self).__init__()
        self.sock_lock = threading.Lock()
        self.sock = socket.socket()
        self._server_ip = server_ip
        self._server_port = server_port
        self.sock.connect((self._server_ip, self._server_port))

        self.cnt_lock = threading.Lock()
        self.cnt = 0

        self.envs_msgs_queues = {}
        self.msgs2send = queue.Queue()

        self.__icon_display_size = icon_display_size
        self.__available_environments_initialization_strings = None
        self.get_available_environments_initialization_strings()

        self.__environments_initialization_strings_to_icons_dict = None
        self.get_environments_initialization_strings_to_icons_dict()

        self.start()  # start operations.

    def run(self):
        &#34;&#34;&#34;
        The RemoteEnvironmentsManager instance main function. Handles the creation and communications of its child
        environments terminals (RemoteEnvironmentTerminal insstances).  

        :return: None
        &#34;&#34;&#34;
        try:
            self.status = Status.Running
            msg = &#34;&#34;
            while self.status == Status.Running:
                with self.sock_lock:
                    rl, wl, _ = select.select([self.sock], [self.sock], [], self.Select_Timeout)
                    if self.sock in rl:
                        msg = receive_by_size(self.sock)
                        self.handle_if_EROR_msg(msg)
                        self.envs_msgs_queues[self.get_msg_env_id(msg)].put(msg)
                        #print(msg[:4], self.get_msg_env_id(msg))
                    if self.sock in wl and not self.msgs2send.empty():
                        send_by_size(self.sock, self.msgs2send.get())
            self._shutdown_procedure()
        except SocketClosedRemotelyError as ex:
            print(&#34;MSG:&#34;, msg)
            raise ex

    def _shutdown_procedure(self):
        &#34;&#34;&#34;
        Shuts down the RemoteEnvironmentsManager instance. Errors will occur should you try to continue and use the
        RemoteEnvironmentTerminal instances created using this manager (by the closed instance).  

        :return: None
        &#34;&#34;&#34;
        with self.sock_lock:
            send_by_size(self.sock, ProtocolHandler.Exit_Msg_Identifier)
            self.sock.close()
        self.status = Status.ShutDown

    def get_server_ip_and_port(self):
        &#34;&#34;&#34;
        Returns the server&#39;s ip and port.  

        :return: The server&#39;s ip and port. (tuple of (ip (string), port(int) ) )
        &#34;&#34;&#34;
        return self._server_ip, self._server_port

    def get_available_environments_initialization_strings(self):
        &#34;&#34;&#34;
        Returns the available environments initialization strings offered by the server.  

        :return: The available environments initialization strings offered by the server.
        &#34;&#34;&#34;
        if self.__available_environments_initialization_strings is None:
            with self.sock_lock:
                send_by_size(self.sock, ProtocolHandler.format_RAES_msg())
                AEIS_msg = receive_by_size(self.sock)
            self.__available_environments_initialization_strings = ProtocolHandler.parse_AEIS_msg(AEIS_msg)
        return self.__available_environments_initialization_strings.copy()

    def get_environments_initialization_strings_to_icons_dict(self):
        &#34;&#34;&#34;
        Returns the available environments initialization strings to icons dict from the server.
        The dict maps each environment initialzation string to their matching icons (the icon are numpy arrays)  

        :return: A dict where the keys, the environment initialization strings, map to their environments&#39; corresponding
            icons (stored as numpy arrays).
        &#34;&#34;&#34;
        if self.__environments_initialization_strings_to_icons_dict is None:
            with self.sock_lock:
                send_by_size(self.sock, ProtocolHandler.format_GTMN_msg(self.__icon_display_size))
                MENU_msg = receive_by_size(self.sock)
            self.__environments_initialization_strings_to_icons_dict = ProtocolHandler.parse_MENU_msg(MENU_msg)
        return self.__environments_initialization_strings_to_icons_dict.copy()

    def get_new_remote_environment_terminal(self, env_init_str, s_size):
        &#34;&#34;&#34;
        Get a new remote environment terminal. Creates an environment in the server and returns an instance of the
        RemoteEnvironmentTerminal class.  

        :param env_init_str: An environment initialization string. (get list of available environment initialization
            string from the self.get_available_environments_initialization_strings() func).  
        :param s_size: Input size, essentially the size of pixels in the screen.(int)  
        :return: An instance of the RemoteEnvironmentTerminal class. The RemoteEnvironmentTerminal class inherits from
            the abstract Environment class there by guaranteeing that it is possible to interact with the returned
            instances via the interface defined in the above mentioned Environment class.
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        env_id = self.get_name_for_new_env()

        self.envs_msgs_queues[env_id] = queue.Queue()
        STNE_msg = ProtocolHandler.format_SEEN_msg(env_id, env_init_str, s_size)
        self.msgs2send.put(STNE_msg)

        NEIN_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_NEIN_msg(NEIN_msg)

        return RemoteEnvironmentTerminal(env_id, msg_dict[&#39;a_size&#39;], self)

    def step(self, env_id, action):
        &#34;&#34;&#34;
        Makes an action and returns a reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :param action: (list) action to do (must be from self.possible_action)  
        :return: reward(float) ( R(s,a) )
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        SA2M_msg = ProtocolHandler.format_SA2M_msg(env_id, action)
        self.msgs2send.put(SA2M_msg)

        STAT_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_STAT_msg(STAT_msg)

        state = msg_dict[&#39;state&#39;]
        reward_for_last_action = msg_dict[&#39;reward_for_last_action&#39;]
        is_terminal = msg_dict[&#39;is_terminal_state&#39;]

        return state, reward_for_last_action, is_terminal

    def get_post_terminal_step_reward(self, env_id):
        &#34;&#34;&#34;
        Returns the post terminal step reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: post terminal step reward (float)
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        GPTR_msg = ProtocolHandler.format_GPTR_msg(env_id)
        self.msgs2send.put(GPTR_msg)

        PTSR_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_PTSR_msg(PTSR_msg)

        post_terminal_step_reward = msg_dict[&#39;post_terminal_step_reward&#39;]

        return post_terminal_step_reward

    def get_unprocessed_state_screen_buffer(self, env_id, requested_screen_size):
        &#34;&#34;&#34;
        Makes an action and returns a reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                             None will return the screen with it&#39;s original size.))  
        :return: unprocessed screen. (numpy array)
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        GUPS_msg = ProtocolHandler.format_GUPS_msg(env_id, requested_screen_size)
        self.msgs2send.put(GUPS_msg)

        UPSC_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_UPSC_msg(UPSC_msg)

        state = msg_dict[&#39;state&#39;]

        return state

    def start_new_episode(self, env_id):
        &#34;&#34;&#34;
        Starts a new episode, returns the initial state and whether or not it is terminal.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: tuple (initial_step (numpy array), is_terminal (bool))
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        STNE_msg = ProtocolHandler.format_STNE_msg(env_id)
        self.msgs2send.put(STNE_msg)

        NEST_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_NEST_msg(NEST_msg)

        return msg_dict[&#39;initial_state&#39;], msg_dict[&#39;is_terminal&#39;]

    def close(self, env_id):
        &#34;&#34;&#34;
        Closes the specified environment.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: None
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        CLEN_msg = ProtocolHandler.format_CLEN_msg(env_id)
        self.msgs2send.put(CLEN_msg)

    def get_name_for_new_env(self):
        &#34;&#34;&#34;
        Utility function. Generates env_ids for new environments.  

        :return: New env_id for a new environment.
        &#34;&#34;&#34;
        with self.cnt_lock:
            name = self.EnvironmentIDFormat % self.cnt
            self.cnt += 1
        return name

    def crash_if_shutdown(self):
        &#34;&#34;&#34;
        Crashes if self is not running.
        Prevents us from trying to communicate with server when sockets have been closed.  

        :return: None
        &#34;&#34;&#34;
        if self.status != Status.Running:
            print(&#34;The RemoteEnvironmentsManager must be running for communication with the server to be possible.&#34;)
            raise ManagerUsedIsNotRunningError()
        
    def get_msg_from_evn_msg_queue(self, env_id):
        &#34;&#34;&#34;
        Fetches the top message in the environment&#39;s msg_queue. Blocks for RemoteEnvironmentsManager.QueueGetTimeout
        seconds. Crashes if queue is empty and wait time is timed out.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: If msg queue isn&#39;t empty, returns the top msg in the queue. Raises an
        TimeoutExceededTryingToGetMsgError error otherwise.
        &#34;&#34;&#34;
        try:
            return self.envs_msgs_queues[env_id].get(timeout=self.QueueGetTimeout)
        except queue.Empty:
            raise TimeoutExceededTryingToGetMsgError()

    @staticmethod
    def get_msg_env_id(msg):
        &#34;&#34;&#34;
        Returns the env_id of the environment for which the msg is meant.  

        :param msg: msg (string)  
        :return: Environment id (string).
        &#34;&#34;&#34;
        msg_id_to_func = {
                          ProtocolHandler.State_Msg_Identifier: ProtocolHandler.parse_STAT_msg,
                          ProtocolHandler.New_Environment_Initiated_Msg_Identifier: ProtocolHandler.parse_NEIN_msg,
                          ProtocolHandler.New_Episode_Started_Msg_Identifier: ProtocolHandler.parse_NEST_msg,
                          ProtocolHandler.Unprocessed_Screen_Msg_Identifier: ProtocolHandler.parse_UPSC_msg,
                          ProtocolHandler.Post_Terminal_Step_Reward_Msg_Identifier: ProtocolHandler.parse_PTSR_msg
                         }
        parsed = msg_id_to_func[msg[:ProtocolHandler.MSG_IDENTIFIER_LEN]](msg)
        if type(parsed) == dict:
            return parsed[&#39;environment_id&#39;]
        else:
            return parsed

    @staticmethod
    def handle_if_EROR_msg(msg):
        &#34;&#34;&#34;
        Checks if the msg is an EROR_msg. If it is, it prints a description and raises an exception.  

        :param msg:  
        :return:
        &#34;&#34;&#34;
        if msg[:ProtocolHandler.MSG_IDENTIFIER_LEN] == ProtocolHandler.Error_Msg_Identifier:
            print(&#39;An Error has occurred! Description: %s&#39; % ProtocolHandler.parse_EROR_msg(msg))
            raise ERORMsgEncountered()

    @staticmethod
    def check_for_server(ip, port):
        &#34;&#34;&#34;
        Returns True if an Environments_Server is listening in (ip, port). False otherwise.  

        :param ip: IP address of server. Assumes the IP address is a valid one. (string)  
        :param port: Server port. Assumes the port number is a valid one. (int)  
        :return: True if an Environments_Server is listening in (ip, port). False otherwise.
        &#34;&#34;&#34;
        sock = socket.socket()
        try:
            try:
                socket.setdefaulttimeout(RemoteEnvironmentsManager.Server_Check_Timeout)
                sock.connect((ip, port))
                socket.setdefaulttimeout(None)
            except socket.timeout:
                socket.setdefaulttimeout(None)
                return False
            send_by_size(sock, ProtocolHandler.format_PING_msg())
            rlist, _, _ = select.select([sock], [], [], RemoteEnvironmentsManager.Server_Check_Timeout)
            if sock in rlist:
                success = receive_by_size(sock)
                send_by_size(sock, ProtocolHandler.format_EXIT_msg())
                return success
        except (ConnectionRefusedError, OSError) as e:
            pass
        return False


class TimeoutExceededTryingToGetMsgError(Exception):
    pass


class ERORMsgEncountered(Exception):
    pass


class ManagerUsedIsNotRunningError(Exception):
    pass


class RemoteEnvironmentTerminal(Environment):
        def __init__(self, env_id, a_size, manager):
            &#34;&#34;&#34;
            A class representing an environment run on a remote server, allowing interaction with said environment from
            this computer using the abstract Environment class interface.
            The instances of this class do not directly communicate with th server. Instead they communicate with the
            RemoteEnvironmentsManager instance set as their manager and it communicates with server for them.  

            :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
            :param a_size: Action space. The number of actions possible in our environment. (int)  
            :param manager: The instance of the RemoteEnvironmentsManager who created the instance.
            &#34;&#34;&#34;
            self.env_id = env_id
            super(RemoteEnvironmentTerminal, self).__init__(a_size)
            self.manager = manager
            self.curr_state = None
            self.last_reward = None
            self.is_curr_state_terminal = None
            self.total_reward = None
            self._post_terminal_step_reward = None

        def step(self, action):
            &#34;&#34;&#34;
            Makes an action and returns a reward.
            self.step() is a wrapper to this function so please use self.step().  

            :param action: (list) action to do (must be from self.possible_action)  
            :return: reward(int) ( R(s,a) )
            &#34;&#34;&#34;
            self.curr_state, self.last_reward, self.is_curr_state_terminal = self.manager.step(self.env_id, action)
            self.total_reward += self.last_reward
            return self.last_reward

        def get_post_terminal_step_reward(self):
            &#34;&#34;&#34;
            Returns the post terminal step reward.  

            :return: post terminal step reward (float)
            &#34;&#34;&#34;
            if self._post_terminal_step_reward is None:
                self._post_terminal_step_reward = self.manager.get_post_terminal_step_reward(self.env_id)
            return self._post_terminal_step_reward

        def get_state_screen_buffer(self):
            &#34;&#34;&#34;
            DO NOT use this function!!! Use the .get_state_screen_buffer() function instead
            returns the current state&#39;s screen buffer.
            self.get_state_screen_buffer() is a wrapper to this function so please use self.get_state_screen_buffer().  

            :return: returns the current state&#39;s screen buffer.
            &#34;&#34;&#34;
            return np.copy(self.curr_state)

        def get_unprocessed_state_screen_buffer(self, requested_screen_size):
            &#34;&#34;&#34;
            returns the unprocessed screen of size requested_screen_size .  

            :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                                 None will return the screen with it&#39;s original size.)  
            :return: returns the unprocessed screen. (numpy array)
            &#34;&#34;&#34;
            return self.manager.get_unprocessed_state_screen_buffer(self.env_id, requested_screen_size)

        def start_new_episode(self):
            &#34;&#34;&#34;
            Starts a new episode.  

            :return: None
            &#34;&#34;&#34;
            self.curr_state, self.is_curr_state_terminal = self.manager.start_new_episode(self.env_id)
            self.total_reward = 0

        def is_episode_finished(self):
            &#34;&#34;&#34;
            Returns True if episode is finished, False otherwise.  

            :return: True if episode is finished, False otherwise.
            &#34;&#34;&#34;
            return self.is_curr_state_terminal

        def get_total_reward(self):
            &#34;&#34;&#34;
            Returns the accumulated total reward from all states since episode start.  

            :return: The accumulated total reward from all states since episode start.
            &#34;&#34;&#34;
            return self.total_reward

        def close(self):
            &#34;&#34;&#34;
            Close environment.  

            :return: None
            &#34;&#34;&#34;
            self.manager.close(self.env_id)
            self.curr_state = None
            self.last_reward = None
            self.is_curr_state_terminal = None
            self.total_reward = None


def main():
    ip, port = &#34;10.0.0.3&#34;, 5381
    env_manager = RemoteEnvironmentsManager(ip, port)
    print(env_manager.get_available_environments_initialization_strings())

    from PIL import Image
    import time
    import os

    def play_episode(thread_name, save_path):
        env = env_manager.get_new_remote_environment_terminal(&#34;Defend_the_Center&#34;, [84, 84])
        cnt = 0
        if not os.path.isdir(save_path):
            os.mkdir(save_path)
        env.start_new_episode()
        while not env.is_episode_finished():
            Image.fromarray(env.get_state_screen_buffer() * 255).convert(&#39;RGB&#39;).save(os.path.join(save_path,
                                                                                                  &#34;%d.bmp&#34; % cnt))
            cnt += 1

            poss_actions = env.possible_actions
            action = poss_actions[np.random.choice(len(poss_actions))]
            env.step(action)
            print(env.is_episode_finished(), thread_name)
        print(&#34;Total Reward:&#34;, env.get_total_reward())
        env.close()

    path = r&#34;test&#34;
    if not os.path.isdir(path):
        os.mkdir(path)
    threads = [threading.Thread(target=play_episode, args=(str(i), os.path.join(path, str(i)))) for i in range(10)]
    start = time.time()
    [t.start() for t in threads]
    [t.join() for t in threads]
    print(time.time() - start)

    env_manager.shutdown()
    env_manager.join()


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Beta.Remote_Environment.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def main():
    ip, port = &#34;10.0.0.3&#34;, 5381
    env_manager = RemoteEnvironmentsManager(ip, port)
    print(env_manager.get_available_environments_initialization_strings())

    from PIL import Image
    import time
    import os

    def play_episode(thread_name, save_path):
        env = env_manager.get_new_remote_environment_terminal(&#34;Defend_the_Center&#34;, [84, 84])
        cnt = 0
        if not os.path.isdir(save_path):
            os.mkdir(save_path)
        env.start_new_episode()
        while not env.is_episode_finished():
            Image.fromarray(env.get_state_screen_buffer() * 255).convert(&#39;RGB&#39;).save(os.path.join(save_path,
                                                                                                  &#34;%d.bmp&#34; % cnt))
            cnt += 1

            poss_actions = env.possible_actions
            action = poss_actions[np.random.choice(len(poss_actions))]
            env.step(action)
            print(env.is_episode_finished(), thread_name)
        print(&#34;Total Reward:&#34;, env.get_total_reward())
        env.close()

    path = r&#34;test&#34;
    if not os.path.isdir(path):
        os.mkdir(path)
    threads = [threading.Thread(target=play_episode, args=(str(i), os.path.join(path, str(i)))) for i in range(10)]
    start = time.time()
    [t.start() for t in threads]
    [t.join() for t in threads]
    print(time.time() - start)

    env_manager.shutdown()
    env_manager.join()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Beta.Remote_Environment.ERORMsgEncountered"><code class="flex name class">
<span>class <span class="ident">ERORMsgEncountered</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ERORMsgEncountered(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="Beta.Remote_Environment.ManagerUsedIsNotRunningError"><code class="flex name class">
<span>class <span class="ident">ManagerUsedIsNotRunningError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ManagerUsedIsNotRunningError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal"><code class="flex name class">
<span>class <span class="ident">RemoteEnvironmentTerminal</span></span>
<span>(</span><span>env_id, a_size, manager)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>A class representing an environment run on a remote server, allowing interaction with said environment from
this computer using the abstract Environment class interface.
The instances of this class do not directly communicate with th server. Instead they communicate with the
RemoteEnvironmentsManager instance set as their manager and it communicates with server for them.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:param a_size: Action space. The number of actions possible in our environment. (int)<br>
:param manager: The instance of the RemoteEnvironmentsManager who created the instance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RemoteEnvironmentTerminal(Environment):
        def __init__(self, env_id, a_size, manager):
            &#34;&#34;&#34;
            A class representing an environment run on a remote server, allowing interaction with said environment from
            this computer using the abstract Environment class interface.
            The instances of this class do not directly communicate with th server. Instead they communicate with the
            RemoteEnvironmentsManager instance set as their manager and it communicates with server for them.  

            :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
            :param a_size: Action space. The number of actions possible in our environment. (int)  
            :param manager: The instance of the RemoteEnvironmentsManager who created the instance.
            &#34;&#34;&#34;
            self.env_id = env_id
            super(RemoteEnvironmentTerminal, self).__init__(a_size)
            self.manager = manager
            self.curr_state = None
            self.last_reward = None
            self.is_curr_state_terminal = None
            self.total_reward = None
            self._post_terminal_step_reward = None

        def step(self, action):
            &#34;&#34;&#34;
            Makes an action and returns a reward.
            self.step() is a wrapper to this function so please use self.step().  

            :param action: (list) action to do (must be from self.possible_action)  
            :return: reward(int) ( R(s,a) )
            &#34;&#34;&#34;
            self.curr_state, self.last_reward, self.is_curr_state_terminal = self.manager.step(self.env_id, action)
            self.total_reward += self.last_reward
            return self.last_reward

        def get_post_terminal_step_reward(self):
            &#34;&#34;&#34;
            Returns the post terminal step reward.  

            :return: post terminal step reward (float)
            &#34;&#34;&#34;
            if self._post_terminal_step_reward is None:
                self._post_terminal_step_reward = self.manager.get_post_terminal_step_reward(self.env_id)
            return self._post_terminal_step_reward

        def get_state_screen_buffer(self):
            &#34;&#34;&#34;
            DO NOT use this function!!! Use the .get_state_screen_buffer() function instead
            returns the current state&#39;s screen buffer.
            self.get_state_screen_buffer() is a wrapper to this function so please use self.get_state_screen_buffer().  

            :return: returns the current state&#39;s screen buffer.
            &#34;&#34;&#34;
            return np.copy(self.curr_state)

        def get_unprocessed_state_screen_buffer(self, requested_screen_size):
            &#34;&#34;&#34;
            returns the unprocessed screen of size requested_screen_size .  

            :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                                 None will return the screen with it&#39;s original size.)  
            :return: returns the unprocessed screen. (numpy array)
            &#34;&#34;&#34;
            return self.manager.get_unprocessed_state_screen_buffer(self.env_id, requested_screen_size)

        def start_new_episode(self):
            &#34;&#34;&#34;
            Starts a new episode.  

            :return: None
            &#34;&#34;&#34;
            self.curr_state, self.is_curr_state_terminal = self.manager.start_new_episode(self.env_id)
            self.total_reward = 0

        def is_episode_finished(self):
            &#34;&#34;&#34;
            Returns True if episode is finished, False otherwise.  

            :return: True if episode is finished, False otherwise.
            &#34;&#34;&#34;
            return self.is_curr_state_terminal

        def get_total_reward(self):
            &#34;&#34;&#34;
            Returns the accumulated total reward from all states since episode start.  

            :return: The accumulated total reward from all states since episode start.
            &#34;&#34;&#34;
            return self.total_reward

        def close(self):
            &#34;&#34;&#34;
            Close environment.  

            :return: None
            &#34;&#34;&#34;
            self.manager.close(self.env_id)
            self.curr_state = None
            self.last_reward = None
            self.is_curr_state_terminal = None
            self.total_reward = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>Server.Environments.Environment</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Close environment.
</p>
<p>:return: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Close environment.  

    :return: None
    &#34;&#34;&#34;
    self.manager.close(self.env_id)
    self.curr_state = None
    self.last_reward = None
    self.is_curr_state_terminal = None
    self.total_reward = None</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_post_terminal_step_reward"><code class="name flex">
<span>def <span class="ident">get_post_terminal_step_reward</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the post terminal step reward.
</p>
<p>:return: post terminal step reward (float)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_post_terminal_step_reward(self):
    &#34;&#34;&#34;
    Returns the post terminal step reward.  

    :return: post terminal step reward (float)
    &#34;&#34;&#34;
    if self._post_terminal_step_reward is None:
        self._post_terminal_step_reward = self.manager.get_post_terminal_step_reward(self.env_id)
    return self._post_terminal_step_reward</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_state_screen_buffer"><code class="name flex">
<span>def <span class="ident">get_state_screen_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>DO NOT use this function!!! Use the .get_state_screen_buffer() function instead
returns the current state's screen buffer.
self.get_state_screen_buffer() is a wrapper to this function so please use self.get_state_screen_buffer().
</p>
<p>:return: returns the current state's screen buffer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_state_screen_buffer(self):
    &#34;&#34;&#34;
    DO NOT use this function!!! Use the .get_state_screen_buffer() function instead
    returns the current state&#39;s screen buffer.
    self.get_state_screen_buffer() is a wrapper to this function so please use self.get_state_screen_buffer().  

    :return: returns the current state&#39;s screen buffer.
    &#34;&#34;&#34;
    return np.copy(self.curr_state)</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_total_reward"><code class="name flex">
<span>def <span class="ident">get_total_reward</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the accumulated total reward from all states since episode start.
</p>
<p>:return: The accumulated total reward from all states since episode start.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_total_reward(self):
    &#34;&#34;&#34;
    Returns the accumulated total reward from all states since episode start.  

    :return: The accumulated total reward from all states since episode start.
    &#34;&#34;&#34;
    return self.total_reward</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_unprocessed_state_screen_buffer"><code class="name flex">
<span>def <span class="ident">get_unprocessed_state_screen_buffer</span></span>(<span>self, requested_screen_size)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the unprocessed screen of size requested_screen_size .
</p>
<p>:param requested_screen_size: requested screen size (tuple of ints, [width, height].
None will return the screen with it's original size.)<br>
:return: returns the unprocessed screen. (numpy array)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unprocessed_state_screen_buffer(self, requested_screen_size):
    &#34;&#34;&#34;
    returns the unprocessed screen of size requested_screen_size .  

    :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                         None will return the screen with it&#39;s original size.)  
    :return: returns the unprocessed screen. (numpy array)
    &#34;&#34;&#34;
    return self.manager.get_unprocessed_state_screen_buffer(self.env_id, requested_screen_size)</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.is_episode_finished"><code class="name flex">
<span>def <span class="ident">is_episode_finished</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if episode is finished, False otherwise.
</p>
<p>:return: True if episode is finished, False otherwise.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_episode_finished(self):
    &#34;&#34;&#34;
    Returns True if episode is finished, False otherwise.  

    :return: True if episode is finished, False otherwise.
    &#34;&#34;&#34;
    return self.is_curr_state_terminal</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.start_new_episode"><code class="name flex">
<span>def <span class="ident">start_new_episode</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Starts a new episode.
</p>
<p>:return: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def start_new_episode(self):
    &#34;&#34;&#34;
    Starts a new episode.  

    :return: None
    &#34;&#34;&#34;
    self.curr_state, self.is_curr_state_terminal = self.manager.start_new_episode(self.env_id)
    self.total_reward = 0</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentTerminal.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes an action and returns a reward.
self.step() is a wrapper to this function so please use self.step().
</p>
<p>:param action: (list) action to do (must be from self.possible_action)<br>
:return: reward(int) ( R(s,a) )</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def step(self, action):
    &#34;&#34;&#34;
    Makes an action and returns a reward.
    self.step() is a wrapper to this function so please use self.step().  

    :param action: (list) action to do (must be from self.possible_action)  
    :return: reward(int) ( R(s,a) )
    &#34;&#34;&#34;
    self.curr_state, self.last_reward, self.is_curr_state_terminal = self.manager.step(self.env_id, action)
    self.total_reward += self.last_reward
    return self.last_reward</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager"><code class="flex name class">
<span>class <span class="ident">RemoteEnvironmentsManager</span></span>
<span>(</span><span>server_ip, server_port, icon_display_size=(250, 250))</span>
</code></dt>
<dd>
<section class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>The instances of these class allow the creation of remote environments run on the server and the interaction
with said environments via the instances of the RemoteEnvironmentTerminal class it creates and passes to the
client.
The user (the programmer using the class, not the user of the project as a whole) only uses this class to create
environments and seemingly uses the instances of the
RemoteEnvironmentTerminal class returned in the
self.get_new_remote_environment_terminal() to interact with the environment run on the server.
Unbeknown to user though, it is the instance of this class that actually handles all communications with the
server. The RemoteEnvironmentTerminal instances communicating through the RemoteEnvironmentsManager instance
that created them.
</p>
<p>:param server_ip: Server ip (string).<br>
:param server_port: Server port (int).<br>
:param icon_display_size: The size of the icon display widget. (tuple of 2 ints (width, height))</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RemoteEnvironmentsManager(Threadable):
    EnvironmentIDFormat = &#34;env%d&#34;
    Select_Timeout = 0.01
    Server_Check_Timeout = 5
    QueueGetTimeout = 5

    def __init__(self, server_ip, server_port, icon_display_size=(250, 250)):
        &#34;&#34;&#34;
        The instances of these class allow the creation of remote environments run on the server and the interaction
        with said environments via the instances of the RemoteEnvironmentTerminal class it creates and passes to the
        client.
        The user (the programmer using the class, not the user of the project as a whole) only uses this class to create
        environments and seemingly uses the instances of the  RemoteEnvironmentTerminal class returned in the
        self.get_new_remote_environment_terminal() to interact with the environment run on the server.
        Unbeknown to user though, it is the instance of this class that actually handles all communications with the
        server. The RemoteEnvironmentTerminal instances communicating through the RemoteEnvironmentsManager instance
        that created them.  

        :param server_ip: Server ip (string).  
        :param server_port: Server port (int).  
        :param icon_display_size: The size of the icon display widget. (tuple of 2 ints (width, height))
        &#34;&#34;&#34;
        super(RemoteEnvironmentsManager, self).__init__()
        self.sock_lock = threading.Lock()
        self.sock = socket.socket()
        self._server_ip = server_ip
        self._server_port = server_port
        self.sock.connect((self._server_ip, self._server_port))

        self.cnt_lock = threading.Lock()
        self.cnt = 0

        self.envs_msgs_queues = {}
        self.msgs2send = queue.Queue()

        self.__icon_display_size = icon_display_size
        self.__available_environments_initialization_strings = None
        self.get_available_environments_initialization_strings()

        self.__environments_initialization_strings_to_icons_dict = None
        self.get_environments_initialization_strings_to_icons_dict()

        self.start()  # start operations.

    def run(self):
        &#34;&#34;&#34;
        The RemoteEnvironmentsManager instance main function. Handles the creation and communications of its child
        environments terminals (RemoteEnvironmentTerminal insstances).  

        :return: None
        &#34;&#34;&#34;
        try:
            self.status = Status.Running
            msg = &#34;&#34;
            while self.status == Status.Running:
                with self.sock_lock:
                    rl, wl, _ = select.select([self.sock], [self.sock], [], self.Select_Timeout)
                    if self.sock in rl:
                        msg = receive_by_size(self.sock)
                        self.handle_if_EROR_msg(msg)
                        self.envs_msgs_queues[self.get_msg_env_id(msg)].put(msg)
                        #print(msg[:4], self.get_msg_env_id(msg))
                    if self.sock in wl and not self.msgs2send.empty():
                        send_by_size(self.sock, self.msgs2send.get())
            self._shutdown_procedure()
        except SocketClosedRemotelyError as ex:
            print(&#34;MSG:&#34;, msg)
            raise ex

    def _shutdown_procedure(self):
        &#34;&#34;&#34;
        Shuts down the RemoteEnvironmentsManager instance. Errors will occur should you try to continue and use the
        RemoteEnvironmentTerminal instances created using this manager (by the closed instance).  

        :return: None
        &#34;&#34;&#34;
        with self.sock_lock:
            send_by_size(self.sock, ProtocolHandler.Exit_Msg_Identifier)
            self.sock.close()
        self.status = Status.ShutDown

    def get_server_ip_and_port(self):
        &#34;&#34;&#34;
        Returns the server&#39;s ip and port.  

        :return: The server&#39;s ip and port. (tuple of (ip (string), port(int) ) )
        &#34;&#34;&#34;
        return self._server_ip, self._server_port

    def get_available_environments_initialization_strings(self):
        &#34;&#34;&#34;
        Returns the available environments initialization strings offered by the server.  

        :return: The available environments initialization strings offered by the server.
        &#34;&#34;&#34;
        if self.__available_environments_initialization_strings is None:
            with self.sock_lock:
                send_by_size(self.sock, ProtocolHandler.format_RAES_msg())
                AEIS_msg = receive_by_size(self.sock)
            self.__available_environments_initialization_strings = ProtocolHandler.parse_AEIS_msg(AEIS_msg)
        return self.__available_environments_initialization_strings.copy()

    def get_environments_initialization_strings_to_icons_dict(self):
        &#34;&#34;&#34;
        Returns the available environments initialization strings to icons dict from the server.
        The dict maps each environment initialzation string to their matching icons (the icon are numpy arrays)  

        :return: A dict where the keys, the environment initialization strings, map to their environments&#39; corresponding
            icons (stored as numpy arrays).
        &#34;&#34;&#34;
        if self.__environments_initialization_strings_to_icons_dict is None:
            with self.sock_lock:
                send_by_size(self.sock, ProtocolHandler.format_GTMN_msg(self.__icon_display_size))
                MENU_msg = receive_by_size(self.sock)
            self.__environments_initialization_strings_to_icons_dict = ProtocolHandler.parse_MENU_msg(MENU_msg)
        return self.__environments_initialization_strings_to_icons_dict.copy()

    def get_new_remote_environment_terminal(self, env_init_str, s_size):
        &#34;&#34;&#34;
        Get a new remote environment terminal. Creates an environment in the server and returns an instance of the
        RemoteEnvironmentTerminal class.  

        :param env_init_str: An environment initialization string. (get list of available environment initialization
            string from the self.get_available_environments_initialization_strings() func).  
        :param s_size: Input size, essentially the size of pixels in the screen.(int)  
        :return: An instance of the RemoteEnvironmentTerminal class. The RemoteEnvironmentTerminal class inherits from
            the abstract Environment class there by guaranteeing that it is possible to interact with the returned
            instances via the interface defined in the above mentioned Environment class.
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        env_id = self.get_name_for_new_env()

        self.envs_msgs_queues[env_id] = queue.Queue()
        STNE_msg = ProtocolHandler.format_SEEN_msg(env_id, env_init_str, s_size)
        self.msgs2send.put(STNE_msg)

        NEIN_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_NEIN_msg(NEIN_msg)

        return RemoteEnvironmentTerminal(env_id, msg_dict[&#39;a_size&#39;], self)

    def step(self, env_id, action):
        &#34;&#34;&#34;
        Makes an action and returns a reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :param action: (list) action to do (must be from self.possible_action)  
        :return: reward(float) ( R(s,a) )
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        SA2M_msg = ProtocolHandler.format_SA2M_msg(env_id, action)
        self.msgs2send.put(SA2M_msg)

        STAT_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_STAT_msg(STAT_msg)

        state = msg_dict[&#39;state&#39;]
        reward_for_last_action = msg_dict[&#39;reward_for_last_action&#39;]
        is_terminal = msg_dict[&#39;is_terminal_state&#39;]

        return state, reward_for_last_action, is_terminal

    def get_post_terminal_step_reward(self, env_id):
        &#34;&#34;&#34;
        Returns the post terminal step reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: post terminal step reward (float)
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        GPTR_msg = ProtocolHandler.format_GPTR_msg(env_id)
        self.msgs2send.put(GPTR_msg)

        PTSR_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_PTSR_msg(PTSR_msg)

        post_terminal_step_reward = msg_dict[&#39;post_terminal_step_reward&#39;]

        return post_terminal_step_reward

    def get_unprocessed_state_screen_buffer(self, env_id, requested_screen_size):
        &#34;&#34;&#34;
        Makes an action and returns a reward.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                             None will return the screen with it&#39;s original size.))  
        :return: unprocessed screen. (numpy array)
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        GUPS_msg = ProtocolHandler.format_GUPS_msg(env_id, requested_screen_size)
        self.msgs2send.put(GUPS_msg)

        UPSC_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_UPSC_msg(UPSC_msg)

        state = msg_dict[&#39;state&#39;]

        return state

    def start_new_episode(self, env_id):
        &#34;&#34;&#34;
        Starts a new episode, returns the initial state and whether or not it is terminal.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: tuple (initial_step (numpy array), is_terminal (bool))
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        STNE_msg = ProtocolHandler.format_STNE_msg(env_id)
        self.msgs2send.put(STNE_msg)

        NEST_msg = self.get_msg_from_evn_msg_queue(env_id)
        msg_dict = ProtocolHandler.parse_NEST_msg(NEST_msg)

        return msg_dict[&#39;initial_state&#39;], msg_dict[&#39;is_terminal&#39;]

    def close(self, env_id):
        &#34;&#34;&#34;
        Closes the specified environment.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: None
        &#34;&#34;&#34;
        self.crash_if_shutdown()

        CLEN_msg = ProtocolHandler.format_CLEN_msg(env_id)
        self.msgs2send.put(CLEN_msg)

    def get_name_for_new_env(self):
        &#34;&#34;&#34;
        Utility function. Generates env_ids for new environments.  

        :return: New env_id for a new environment.
        &#34;&#34;&#34;
        with self.cnt_lock:
            name = self.EnvironmentIDFormat % self.cnt
            self.cnt += 1
        return name

    def crash_if_shutdown(self):
        &#34;&#34;&#34;
        Crashes if self is not running.
        Prevents us from trying to communicate with server when sockets have been closed.  

        :return: None
        &#34;&#34;&#34;
        if self.status != Status.Running:
            print(&#34;The RemoteEnvironmentsManager must be running for communication with the server to be possible.&#34;)
            raise ManagerUsedIsNotRunningError()
        
    def get_msg_from_evn_msg_queue(self, env_id):
        &#34;&#34;&#34;
        Fetches the top message in the environment&#39;s msg_queue. Blocks for RemoteEnvironmentsManager.QueueGetTimeout
        seconds. Crashes if queue is empty and wait time is timed out.  

        :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
        :return: If msg queue isn&#39;t empty, returns the top msg in the queue. Raises an
        TimeoutExceededTryingToGetMsgError error otherwise.
        &#34;&#34;&#34;
        try:
            return self.envs_msgs_queues[env_id].get(timeout=self.QueueGetTimeout)
        except queue.Empty:
            raise TimeoutExceededTryingToGetMsgError()

    @staticmethod
    def get_msg_env_id(msg):
        &#34;&#34;&#34;
        Returns the env_id of the environment for which the msg is meant.  

        :param msg: msg (string)  
        :return: Environment id (string).
        &#34;&#34;&#34;
        msg_id_to_func = {
                          ProtocolHandler.State_Msg_Identifier: ProtocolHandler.parse_STAT_msg,
                          ProtocolHandler.New_Environment_Initiated_Msg_Identifier: ProtocolHandler.parse_NEIN_msg,
                          ProtocolHandler.New_Episode_Started_Msg_Identifier: ProtocolHandler.parse_NEST_msg,
                          ProtocolHandler.Unprocessed_Screen_Msg_Identifier: ProtocolHandler.parse_UPSC_msg,
                          ProtocolHandler.Post_Terminal_Step_Reward_Msg_Identifier: ProtocolHandler.parse_PTSR_msg
                         }
        parsed = msg_id_to_func[msg[:ProtocolHandler.MSG_IDENTIFIER_LEN]](msg)
        if type(parsed) == dict:
            return parsed[&#39;environment_id&#39;]
        else:
            return parsed

    @staticmethod
    def handle_if_EROR_msg(msg):
        &#34;&#34;&#34;
        Checks if the msg is an EROR_msg. If it is, it prints a description and raises an exception.  

        :param msg:  
        :return:
        &#34;&#34;&#34;
        if msg[:ProtocolHandler.MSG_IDENTIFIER_LEN] == ProtocolHandler.Error_Msg_Identifier:
            print(&#39;An Error has occurred! Description: %s&#39; % ProtocolHandler.parse_EROR_msg(msg))
            raise ERORMsgEncountered()

    @staticmethod
    def check_for_server(ip, port):
        &#34;&#34;&#34;
        Returns True if an Environments_Server is listening in (ip, port). False otherwise.  

        :param ip: IP address of server. Assumes the IP address is a valid one. (string)  
        :param port: Server port. Assumes the port number is a valid one. (int)  
        :return: True if an Environments_Server is listening in (ip, port). False otherwise.
        &#34;&#34;&#34;
        sock = socket.socket()
        try:
            try:
                socket.setdefaulttimeout(RemoteEnvironmentsManager.Server_Check_Timeout)
                sock.connect((ip, port))
                socket.setdefaulttimeout(None)
            except socket.timeout:
                socket.setdefaulttimeout(None)
                return False
            send_by_size(sock, ProtocolHandler.format_PING_msg())
            rlist, _, _ = select.select([sock], [], [], RemoteEnvironmentsManager.Server_Check_Timeout)
            if sock in rlist:
                success = receive_by_size(sock)
                send_by_size(sock, ProtocolHandler.format_EXIT_msg())
                return success
        except (ConnectionRefusedError, OSError) as e:
            pass
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>Server.Shared_Code.Threadable</li>
<li>threading.Thread</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.EnvironmentIDFormat"><code class="name">var <span class="ident">EnvironmentIDFormat</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.QueueGetTimeout"><code class="name">var <span class="ident">QueueGetTimeout</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.Select_Timeout"><code class="name">var <span class="ident">Select_Timeout</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.Server_Check_Timeout"><code class="name">var <span class="ident">Server_Check_Timeout</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.check_for_server"><code class="name flex">
<span>def <span class="ident">check_for_server</span></span>(<span>ip, port)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if an Environments_Server is listening in (ip, port). False otherwise.
</p>
<p>:param ip: IP address of server. Assumes the IP address is a valid one. (string)<br>
:param port: Server port. Assumes the port number is a valid one. (int)<br>
:return: True if an Environments_Server is listening in (ip, port). False otherwise.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def check_for_server(ip, port):
    &#34;&#34;&#34;
    Returns True if an Environments_Server is listening in (ip, port). False otherwise.  

    :param ip: IP address of server. Assumes the IP address is a valid one. (string)  
    :param port: Server port. Assumes the port number is a valid one. (int)  
    :return: True if an Environments_Server is listening in (ip, port). False otherwise.
    &#34;&#34;&#34;
    sock = socket.socket()
    try:
        try:
            socket.setdefaulttimeout(RemoteEnvironmentsManager.Server_Check_Timeout)
            sock.connect((ip, port))
            socket.setdefaulttimeout(None)
        except socket.timeout:
            socket.setdefaulttimeout(None)
            return False
        send_by_size(sock, ProtocolHandler.format_PING_msg())
        rlist, _, _ = select.select([sock], [], [], RemoteEnvironmentsManager.Server_Check_Timeout)
        if sock in rlist:
            success = receive_by_size(sock)
            send_by_size(sock, ProtocolHandler.format_EXIT_msg())
            return success
    except (ConnectionRefusedError, OSError) as e:
        pass
    return False</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_env_id"><code class="name flex">
<span>def <span class="ident">get_msg_env_id</span></span>(<span>msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the env_id of the environment for which the msg is meant.
</p>
<p>:param msg: msg (string)<br>
:return: Environment id (string).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_msg_env_id(msg):
    &#34;&#34;&#34;
    Returns the env_id of the environment for which the msg is meant.  

    :param msg: msg (string)  
    :return: Environment id (string).
    &#34;&#34;&#34;
    msg_id_to_func = {
                      ProtocolHandler.State_Msg_Identifier: ProtocolHandler.parse_STAT_msg,
                      ProtocolHandler.New_Environment_Initiated_Msg_Identifier: ProtocolHandler.parse_NEIN_msg,
                      ProtocolHandler.New_Episode_Started_Msg_Identifier: ProtocolHandler.parse_NEST_msg,
                      ProtocolHandler.Unprocessed_Screen_Msg_Identifier: ProtocolHandler.parse_UPSC_msg,
                      ProtocolHandler.Post_Terminal_Step_Reward_Msg_Identifier: ProtocolHandler.parse_PTSR_msg
                     }
    parsed = msg_id_to_func[msg[:ProtocolHandler.MSG_IDENTIFIER_LEN]](msg)
    if type(parsed) == dict:
        return parsed[&#39;environment_id&#39;]
    else:
        return parsed</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.handle_if_EROR_msg"><code class="name flex">
<span>def <span class="ident">handle_if_EROR_msg</span></span>(<span>msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the msg is an EROR_msg. If it is, it prints a description and raises an exception.
</p>
<p>:param msg:<br>
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def handle_if_EROR_msg(msg):
    &#34;&#34;&#34;
    Checks if the msg is an EROR_msg. If it is, it prints a description and raises an exception.  

    :param msg:  
    :return:
    &#34;&#34;&#34;
    if msg[:ProtocolHandler.MSG_IDENTIFIER_LEN] == ProtocolHandler.Error_Msg_Identifier:
        print(&#39;An Error has occurred! Description: %s&#39; % ProtocolHandler.parse_EROR_msg(msg))
        raise ERORMsgEncountered()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, env_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Closes the specified environment.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:return: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def close(self, env_id):
    &#34;&#34;&#34;
    Closes the specified environment.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :return: None
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    CLEN_msg = ProtocolHandler.format_CLEN_msg(env_id)
    self.msgs2send.put(CLEN_msg)</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.crash_if_shutdown"><code class="name flex">
<span>def <span class="ident">crash_if_shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Crashes if self is not running.
Prevents us from trying to communicate with server when sockets have been closed.
</p>
<p>:return: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def crash_if_shutdown(self):
    &#34;&#34;&#34;
    Crashes if self is not running.
    Prevents us from trying to communicate with server when sockets have been closed.  

    :return: None
    &#34;&#34;&#34;
    if self.status != Status.Running:
        print(&#34;The RemoteEnvironmentsManager must be running for communication with the server to be possible.&#34;)
        raise ManagerUsedIsNotRunningError()</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_available_environments_initialization_strings"><code class="name flex">
<span>def <span class="ident">get_available_environments_initialization_strings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the available environments initialization strings offered by the server.
</p>
<p>:return: The available environments initialization strings offered by the server.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_available_environments_initialization_strings(self):
    &#34;&#34;&#34;
    Returns the available environments initialization strings offered by the server.  

    :return: The available environments initialization strings offered by the server.
    &#34;&#34;&#34;
    if self.__available_environments_initialization_strings is None:
        with self.sock_lock:
            send_by_size(self.sock, ProtocolHandler.format_RAES_msg())
            AEIS_msg = receive_by_size(self.sock)
        self.__available_environments_initialization_strings = ProtocolHandler.parse_AEIS_msg(AEIS_msg)
    return self.__available_environments_initialization_strings.copy()</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_environments_initialization_strings_to_icons_dict"><code class="name flex">
<span>def <span class="ident">get_environments_initialization_strings_to_icons_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the available environments initialization strings to icons dict from the server.
The dict maps each environment initialzation string to their matching icons (the icon are numpy arrays)
</p>
<p>:return: A dict where the keys, the environment initialization strings, map to their environments' corresponding
icons (stored as numpy arrays).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_environments_initialization_strings_to_icons_dict(self):
    &#34;&#34;&#34;
    Returns the available environments initialization strings to icons dict from the server.
    The dict maps each environment initialzation string to their matching icons (the icon are numpy arrays)  

    :return: A dict where the keys, the environment initialization strings, map to their environments&#39; corresponding
        icons (stored as numpy arrays).
    &#34;&#34;&#34;
    if self.__environments_initialization_strings_to_icons_dict is None:
        with self.sock_lock:
            send_by_size(self.sock, ProtocolHandler.format_GTMN_msg(self.__icon_display_size))
            MENU_msg = receive_by_size(self.sock)
        self.__environments_initialization_strings_to_icons_dict = ProtocolHandler.parse_MENU_msg(MENU_msg)
    return self.__environments_initialization_strings_to_icons_dict.copy()</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_from_evn_msg_queue"><code class="name flex">
<span>def <span class="ident">get_msg_from_evn_msg_queue</span></span>(<span>self, env_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Fetches the top message in the environment's msg_queue. Blocks for RemoteEnvironmentsManager.QueueGetTimeout
seconds. Crashes if queue is empty and wait time is timed out.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:return: If msg queue isn't empty, returns the top msg in the queue. Raises an
TimeoutExceededTryingToGetMsgError error otherwise.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_msg_from_evn_msg_queue(self, env_id):
    &#34;&#34;&#34;
    Fetches the top message in the environment&#39;s msg_queue. Blocks for RemoteEnvironmentsManager.QueueGetTimeout
    seconds. Crashes if queue is empty and wait time is timed out.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :return: If msg queue isn&#39;t empty, returns the top msg in the queue. Raises an
    TimeoutExceededTryingToGetMsgError error otherwise.
    &#34;&#34;&#34;
    try:
        return self.envs_msgs_queues[env_id].get(timeout=self.QueueGetTimeout)
    except queue.Empty:
        raise TimeoutExceededTryingToGetMsgError()</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_name_for_new_env"><code class="name flex">
<span>def <span class="ident">get_name_for_new_env</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility function. Generates env_ids for new environments.
</p>
<p>:return: New env_id for a new environment.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_name_for_new_env(self):
    &#34;&#34;&#34;
    Utility function. Generates env_ids for new environments.  

    :return: New env_id for a new environment.
    &#34;&#34;&#34;
    with self.cnt_lock:
        name = self.EnvironmentIDFormat % self.cnt
        self.cnt += 1
    return name</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_new_remote_environment_terminal"><code class="name flex">
<span>def <span class="ident">get_new_remote_environment_terminal</span></span>(<span>self, env_init_str, s_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a new remote environment terminal. Creates an environment in the server and returns an instance of the
RemoteEnvironmentTerminal class.
</p>
<p>:param env_init_str: An environment initialization string. (get list of available environment initialization
string from the self.get_available_environments_initialization_strings() func).<br>
:param s_size: Input size, essentially the size of pixels in the screen.(int)<br>
:return: An instance of the RemoteEnvironmentTerminal class. The RemoteEnvironmentTerminal class inherits from
the abstract Environment class there by guaranteeing that it is possible to interact with the returned
instances via the interface defined in the above mentioned Environment class.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_new_remote_environment_terminal(self, env_init_str, s_size):
    &#34;&#34;&#34;
    Get a new remote environment terminal. Creates an environment in the server and returns an instance of the
    RemoteEnvironmentTerminal class.  

    :param env_init_str: An environment initialization string. (get list of available environment initialization
        string from the self.get_available_environments_initialization_strings() func).  
    :param s_size: Input size, essentially the size of pixels in the screen.(int)  
    :return: An instance of the RemoteEnvironmentTerminal class. The RemoteEnvironmentTerminal class inherits from
        the abstract Environment class there by guaranteeing that it is possible to interact with the returned
        instances via the interface defined in the above mentioned Environment class.
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    env_id = self.get_name_for_new_env()

    self.envs_msgs_queues[env_id] = queue.Queue()
    STNE_msg = ProtocolHandler.format_SEEN_msg(env_id, env_init_str, s_size)
    self.msgs2send.put(STNE_msg)

    NEIN_msg = self.get_msg_from_evn_msg_queue(env_id)
    msg_dict = ProtocolHandler.parse_NEIN_msg(NEIN_msg)

    return RemoteEnvironmentTerminal(env_id, msg_dict[&#39;a_size&#39;], self)</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_post_terminal_step_reward"><code class="name flex">
<span>def <span class="ident">get_post_terminal_step_reward</span></span>(<span>self, env_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the post terminal step reward.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:return: post terminal step reward (float)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_post_terminal_step_reward(self, env_id):
    &#34;&#34;&#34;
    Returns the post terminal step reward.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :return: post terminal step reward (float)
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    GPTR_msg = ProtocolHandler.format_GPTR_msg(env_id)
    self.msgs2send.put(GPTR_msg)

    PTSR_msg = self.get_msg_from_evn_msg_queue(env_id)
    msg_dict = ProtocolHandler.parse_PTSR_msg(PTSR_msg)

    post_terminal_step_reward = msg_dict[&#39;post_terminal_step_reward&#39;]

    return post_terminal_step_reward</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_server_ip_and_port"><code class="name flex">
<span>def <span class="ident">get_server_ip_and_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the server's ip and port.
</p>
<p>:return: The server's ip and port. (tuple of (ip (string), port(int) ) )</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_server_ip_and_port(self):
    &#34;&#34;&#34;
    Returns the server&#39;s ip and port.  

    :return: The server&#39;s ip and port. (tuple of (ip (string), port(int) ) )
    &#34;&#34;&#34;
    return self._server_ip, self._server_port</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.get_unprocessed_state_screen_buffer"><code class="name flex">
<span>def <span class="ident">get_unprocessed_state_screen_buffer</span></span>(<span>self, env_id, requested_screen_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes an action and returns a reward.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:param requested_screen_size: requested screen size (tuple of ints, [width, height].
None will return the screen with it's original size.))<br>
:return: unprocessed screen. (numpy array)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unprocessed_state_screen_buffer(self, env_id, requested_screen_size):
    &#34;&#34;&#34;
    Makes an action and returns a reward.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :param requested_screen_size: requested screen size (tuple of ints, [width, height].
                                                         None will return the screen with it&#39;s original size.))  
    :return: unprocessed screen. (numpy array)
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    GUPS_msg = ProtocolHandler.format_GUPS_msg(env_id, requested_screen_size)
    self.msgs2send.put(GUPS_msg)

    UPSC_msg = self.get_msg_from_evn_msg_queue(env_id)
    msg_dict = ProtocolHandler.parse_UPSC_msg(UPSC_msg)

    state = msg_dict[&#39;state&#39;]

    return state</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The RemoteEnvironmentsManager instance main function. Handles the creation and communications of its child
environments terminals (RemoteEnvironmentTerminal insstances).
</p>
<p>:return: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    The RemoteEnvironmentsManager instance main function. Handles the creation and communications of its child
    environments terminals (RemoteEnvironmentTerminal insstances).  

    :return: None
    &#34;&#34;&#34;
    try:
        self.status = Status.Running
        msg = &#34;&#34;
        while self.status == Status.Running:
            with self.sock_lock:
                rl, wl, _ = select.select([self.sock], [self.sock], [], self.Select_Timeout)
                if self.sock in rl:
                    msg = receive_by_size(self.sock)
                    self.handle_if_EROR_msg(msg)
                    self.envs_msgs_queues[self.get_msg_env_id(msg)].put(msg)
                    #print(msg[:4], self.get_msg_env_id(msg))
                if self.sock in wl and not self.msgs2send.empty():
                    send_by_size(self.sock, self.msgs2send.get())
        self._shutdown_procedure()
    except SocketClosedRemotelyError as ex:
        print(&#34;MSG:&#34;, msg)
        raise ex</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.start_new_episode"><code class="name flex">
<span>def <span class="ident">start_new_episode</span></span>(<span>self, env_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Starts a new episode, returns the initial state and whether or not it is terminal.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:return: tuple (initial_step (numpy array), is_terminal (bool))</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def start_new_episode(self, env_id):
    &#34;&#34;&#34;
    Starts a new episode, returns the initial state and whether or not it is terminal.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :return: tuple (initial_step (numpy array), is_terminal (bool))
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    STNE_msg = ProtocolHandler.format_STNE_msg(env_id)
    self.msgs2send.put(STNE_msg)

    NEST_msg = self.get_msg_from_evn_msg_queue(env_id)
    msg_dict = ProtocolHandler.parse_NEST_msg(NEST_msg)

    return msg_dict[&#39;initial_state&#39;], msg_dict[&#39;is_terminal&#39;]</code></pre>
</details>
</dd>
<dt id="Beta.Remote_Environment.RemoteEnvironmentsManager.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, env_id, action)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes an action and returns a reward.
</p>
<p>:param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.<br>
:param action: (list) action to do (must be from self.possible_action)<br>
:return: reward(float) ( R(s,a) )</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def step(self, env_id, action):
    &#34;&#34;&#34;
    Makes an action and returns a reward.  

    :param env_id: (string) used to identify the environment. See docs in ProtocolHandler class.  
    :param action: (list) action to do (must be from self.possible_action)  
    :return: reward(float) ( R(s,a) )
    &#34;&#34;&#34;
    self.crash_if_shutdown()

    SA2M_msg = ProtocolHandler.format_SA2M_msg(env_id, action)
    self.msgs2send.put(SA2M_msg)

    STAT_msg = self.get_msg_from_evn_msg_queue(env_id)
    msg_dict = ProtocolHandler.parse_STAT_msg(STAT_msg)

    state = msg_dict[&#39;state&#39;]
    reward_for_last_action = msg_dict[&#39;reward_for_last_action&#39;]
    is_terminal = msg_dict[&#39;is_terminal_state&#39;]

    return state, reward_for_last_action, is_terminal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Beta.Remote_Environment.TimeoutExceededTryingToGetMsgError"><code class="flex name class">
<span>class <span class="ident">TimeoutExceededTryingToGetMsgError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TimeoutExceededTryingToGetMsgError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Beta" href="index.html">Beta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Beta.Remote_Environment.main" href="#Beta.Remote_Environment.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Beta.Remote_Environment.ERORMsgEncountered" href="#Beta.Remote_Environment.ERORMsgEncountered">ERORMsgEncountered</a></code></h4>
</li>
<li>
<h4><code><a title="Beta.Remote_Environment.ManagerUsedIsNotRunningError" href="#Beta.Remote_Environment.ManagerUsedIsNotRunningError">ManagerUsedIsNotRunningError</a></code></h4>
</li>
<li>
<h4><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal">RemoteEnvironmentTerminal</a></code></h4>
<ul class="">
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.close" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.close">close</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_post_terminal_step_reward" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.get_post_terminal_step_reward">get_post_terminal_step_reward</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_state_screen_buffer" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.get_state_screen_buffer">get_state_screen_buffer</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_total_reward" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.get_total_reward">get_total_reward</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.get_unprocessed_state_screen_buffer" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.get_unprocessed_state_screen_buffer">get_unprocessed_state_screen_buffer</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.is_episode_finished" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.is_episode_finished">is_episode_finished</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.start_new_episode" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.start_new_episode">start_new_episode</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentTerminal.step" href="#Beta.Remote_Environment.RemoteEnvironmentTerminal.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager" href="#Beta.Remote_Environment.RemoteEnvironmentsManager">RemoteEnvironmentsManager</a></code></h4>
<ul class="">
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.EnvironmentIDFormat" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.EnvironmentIDFormat">EnvironmentIDFormat</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.QueueGetTimeout" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.QueueGetTimeout">QueueGetTimeout</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.Select_Timeout" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.Select_Timeout">Select_Timeout</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.Server_Check_Timeout" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.Server_Check_Timeout">Server_Check_Timeout</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.check_for_server" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.check_for_server">check_for_server</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.close" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.close">close</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.crash_if_shutdown" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.crash_if_shutdown">crash_if_shutdown</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_available_environments_initialization_strings" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_available_environments_initialization_strings">get_available_environments_initialization_strings</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_environments_initialization_strings_to_icons_dict" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_environments_initialization_strings_to_icons_dict">get_environments_initialization_strings_to_icons_dict</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_env_id" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_env_id">get_msg_env_id</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_from_evn_msg_queue" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_msg_from_evn_msg_queue">get_msg_from_evn_msg_queue</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_name_for_new_env" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_name_for_new_env">get_name_for_new_env</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_new_remote_environment_terminal" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_new_remote_environment_terminal">get_new_remote_environment_terminal</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_post_terminal_step_reward" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_post_terminal_step_reward">get_post_terminal_step_reward</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_server_ip_and_port" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_server_ip_and_port">get_server_ip_and_port</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.get_unprocessed_state_screen_buffer" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.get_unprocessed_state_screen_buffer">get_unprocessed_state_screen_buffer</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.handle_if_EROR_msg" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.handle_if_EROR_msg">handle_if_EROR_msg</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.run" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.run">run</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.start_new_episode" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.start_new_episode">start_new_episode</a></code></li>
<li><code><a title="Beta.Remote_Environment.RemoteEnvironmentsManager.step" href="#Beta.Remote_Environment.RemoteEnvironmentsManager.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Beta.Remote_Environment.TimeoutExceededTryingToGetMsgError" href="#Beta.Remote_Environment.TimeoutExceededTryingToGetMsgError">TimeoutExceededTryingToGetMsgError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>